{"version":3,"sources":["../src/_wrapper_shared.js"],"names":["safeModuleWrapper","oldModule","connectionFunc","newModule","Object","getOwnPropertyNames","forEach","name","Agent","options","prototype","createConnection","safeConnectionWrapper","addrValidator","JSON","stringify","request","safeRequestWrapper","get","cb","req","end","globalAgent","isParanoid","needLocalAddressHack","semver","lt","process","version","fn","safeRequestWrappedFn","url","parse","util","_extend","AddrValidator","agent","_defaultAgent","socketPath","stubSocketError","errors","UnacceptableAddressError","localAddress","undefined","Error","call","err","sock","net","Socket","connect","nextTick","destroy","wrappingSafeConnect","safeConnectionWrappedFn","args","_normalizeConnectArgs","arguments","isSafePort","port","resolved","dnsErr","newOptions","lookupOpts","safeLookup","host","address","family","require","loopWhile","apply","sanitizeAddresses","addresses","map","ip","toString","toBuffer","filter","isSafeIP","bind","defaults","all","optionsArg","dns","lookupService","lookup","length","sanitizedAddresses"],"mappings":"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","file":"_wrapper_shared.js","sourcesContent":["// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* globals process */\n\nimport dns from 'dns';\nimport net from 'net';\nimport url from 'url';\nimport util from 'util';\nimport deepcopy from 'deepcopy';\nimport ip from 'ip';\nimport semver from 'semver';\nimport errors from './errors';\nimport AddrValidator from './addr_validator';\n\n// Wraps one of the stdlib's HTTP(S)? modules to do paranoid checks on connect.\nconst safeModuleWrapper = (oldModule, connectionFunc) => {\n  // Copy the inner modules props to us\n  // TODO: create properties that read from the inner module until mutation?\n  const newModule = {};\n\n  Object.getOwnPropertyNames(oldModule).forEach(name => {\n    newModule[name] = oldModule[name];\n  });\n\n  class Agent extends oldModule.Agent {\n    constructor(options) {\n      super(options);\n      // In Node 0.10 `createConnection` is set on the instance in the constructor\n      // only add it here if we really need to.\n      if (!oldModule.Agent.prototype.createConnection) {\n        this.createConnection = connectionFunc || safeConnectionWrapper(this.createConnection);\n      }\n    }\n\n    getName(options) {\n      // Give our instances a unique name to make sure we don't share a pool\n      // with non-paranoid connections\n      let name = super.getName(options);\n      name += ':paranoid!';\n      if (options.addrValidator) {\n        name += ':';\n        name += JSON.stringify(options.addrValidator);\n      }\n      return name;\n    }\n  }\n\n  if (Agent.prototype.createConnection) {\n    Agent.prototype.createConnection = connectionFunc ||\n      safeConnectionWrapper(Agent.prototype.createConnection);\n  }\n\n  newModule.Agent = Agent;\n  newModule.request = safeRequestWrapper(newModule, oldModule.request);\n  newModule.get = (options, cb) => {\n    const req = newModule.request(options, cb);\n    req.end();\n    return req;\n  };\n\n  newModule.globalAgent = new Agent();\n  newModule.isParanoid = true;\n  return newModule;\n};\n\nconst needLocalAddressHack = semver.lt(process.version, '0.11.0');\n\n// Wraps around <module>.request to make sure our agent gets used\nfunction safeRequestWrapper(newModule, fn) {\n  return function safeRequestWrappedFn(options, cb) { // eslint-disable-line max-statements\n    if (typeof options === 'string') {\n      options = url.parse(options);\n    } else {\n      options = util._extend({}, options);\n    }\n\n    if (!options.addrValidator) {\n      options.addrValidator = new AddrValidator();\n    } else {\n      // This is included in the conn pool key, so we need to be\n      // safe against idiots like me mutating it after the original\n      // request!\n      options.addrValidator = new AddrValidator(deepcopy(options.addrValidator));\n    }\n    // No connection pooling, create an agent just for this\n    // request.\n    if (options.agent === false) {\n      options.agent = new newModule.Agent();\n      // otherwise falsy agent, use the global one for the module\n    } else if (!options.agent) {\n      options.agent = newModule.globalAgent;\n    }\n\n    if (!options._defaultAgent) {\n      options._defaultAgent = new newModule.Agent();\n    }\n\n    if (options.socketPath) {\n      // Node < 0.12 won't use the agent's `createConnection` and has\n      // wonky behaviour if you set `options.createConnection`. Try to\n      // catch this here instead.\n      return stubSocketError(new errors.UnacceptableAddressError(\n        'UNIX domain sockets are not allowed'\n      ));\n    }\n\n    // Great, Node 0.10 won't let us pass arbitrary options down to\n    // `createConnection()`. Hack around that by smuggling it through\n    // the `localAddress` option (which an HTTP client won't use)\n    if (needLocalAddressHack && options.addrValidator) {\n      if (options.localAddress !== undefined) {\n        throw new Error('Can\\'t use validator param hack with defined localAddress!');\n      }\n      options.localAddress = options.addrValidator;\n    }\n    return fn.call(this, options, cb); // eslint-disable-line no-invalid-this\n  };\n}\n\n// A stupid hack around request not being able to handle\n// errors thrown during the synchronous part of socket setup.\n// return a socket whose only purpose is to give async errors\n// see https://github.com/request/request/issues/1946\nfunction stubSocketError(err) {\n  const sock = new net.Socket();\n  sock.connect = null;\n  // Give the caller time to register their error listeners.\n  process.nextTick(() => {\n    sock.destroy(err);\n  });\n  return sock;\n}\n\n// Wraps around net.createConnection()\nfunction safeConnectionWrapper(fn, wrappingSafeConnect) {\n  // Does the function that we're wrapping handle its own DNS lookups? If so, we don't\n  // need to do our always-safe blocking lookup.\n  wrappingSafeConnect = (wrappingSafeConnect || false);\n\n  return function safeConnectionWrappedFn() { // eslint-disable-line max-statements\n    const args = net._normalizeConnectArgs(arguments);\n    const options = args[0];\n\n    // We smuggled our validator through localAddress\n    if (options.localAddress instanceof AddrValidator) {\n      options.addrValidator = options.localAddress;\n      options.localAddress = undefined;\n    }\n    if (!options.addrValidator) {\n      options.addrValidator = new AddrValidator();\n    }\n\n    // It won't use TCP/IP, It's a unix domain socket. Exterminate.\n    if (options.socketPath) {\n      return stubSocketError(new errors.UnacceptableAddressError(\n        'UNIX domain sockets are not allowed'\n      ));\n    }\n\n    if (!options.addrValidator.isSafePort(options.port)) {\n      return stubSocketError(new errors.UnacceptableAddressError(\n        'Disallowed port detected'\n      ));\n    }\n    // So here's the skinny. Normally `.createConnection()` and co create the socket,\n    // then return the created socket while the hostname lookup and connection attempt\n    // happen in the background. No problem, `net.Socket.connect` accepts a `lookup` option\n    // with a function to use instead of `dns.lookup` so we can filter records!\n    //\n    // Unfortunately, it never calls it if the address looks like an IP, and\n    // `tls.connect` doesn't honor it at all. The `http` module basically just calls out to\n    // the super-simple and stable `net.createConnection` function, so we can just rewrite that\n    // entirely.\n    //\n    // The `https` module, however, has a very unstable implementation as does the underlying `tls`\n    // module. Neither gives us an easy way to either use our own socket, or make a lookup happen\n    // before the `connect()` call.\n    //\n    // Rather than detect node versions and use a different hacked up version of the tls module\n    // based on Node version, let's just do a synchronous DNS lookup\n    // if we can't easily do it asynchronously.\n    if (!wrappingSafeConnect) {\n      let resolved = false;\n      let dnsErr = null;\n      const newOptions = util._extend({}, options);\n      const lookupOpts = {addrValidator: options.addrValidator};\n      safeLookup(options.host, lookupOpts, (err, address, family) => {\n        // Connect to the resolved IP when we call `sock.connect()` to avoid TOCTOU vulns\n        // via DNS rebinding.\n        newOptions.host = address;\n        args[0] = newOptions;\n        dnsErr = err;\n        resolved = true;\n      });\n      // Sit around while we wait for the lookup to complete\n      require('deasync').loopWhile(() => !resolved);\n      if (dnsErr) {\n        return stubSocketError(dnsErr);\n      }\n    }\n    // Call our wrapped `createConnection()`\n    return fn.apply(this, args); // eslint-disable-line no-invalid-this\n  };\n}\n\nfunction sanitizeAddresses(addresses, addrValidator) {\n  return addresses\n    .map(address => ip.toString(ip.toBuffer(address.address)))\n    .filter(addrValidator.isSafeIP.bind(addrValidator));\n}\n\nfunction safeLookup(host, options, cb) {\n  const defaults = {\n    // No love for RFC1918 in IPv6-land == no safety via this lib.\n    family: 4,\n    all: true\n  };\n\n  options = util._extend(defaults, options);\n\n  let optionsArg = options;\n  // Looks like we have an older version of the DNS API, it expects a plain\n  // 'ol family number for the second arg.\n  if (!dns.lookupService) {\n    optionsArg = options.family;\n  }\n  dns.lookup(host, optionsArg, (err, addresses, family) => {\n    if (err || !addresses || !addresses.length) {\n      return cb(err, null, family);\n    }\n\n    // Some versions of node don't care that we want _all_ addresses.\n    if (typeof addresses === 'string') {\n      addresses = [{address: addresses, family}];\n    }\n\n    const sanitizedAddresses = sanitizeAddresses(addresses, options.addrValidator);\n\n    let address = {address: null, family: options.family};\n\n    if (sanitizedAddresses.length) {\n      address = addresses[0];\n    } else {\n      err = new errors.UnacceptableAddressError('All addresses were blacklisted!');\n    }\n\n    return cb(err, address.address, address.family);\n  });\n}\n\nexport default {\n  safeLookup,\n  safeConnectionWrapper,\n  safeModuleWrapper,\n  sanitizeAddresses\n};\n"]}